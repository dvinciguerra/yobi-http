#!env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift(File.expand_path("../lib", __dir__))

require "erb"
require "json"
require "net/http"
require "optparse"
require "time"
require "tty-markdown"
require "uri"

require "yobi"

# parsing arguments
@options = {
  print: "HB", auth: nil, auth_type: "basic", verbose: false, raw: false, offline: false, follow: false, debug: false,
  timeout: nil, download: false
}

parser = OptionParser.new do |opts|
  opts.banner = %(
  #{Yobi.name} - #{Yobi.description}

  Usage:
    yobi [METHOD] <url> [HEADER:VALUE] [key=value]

  Examples:
    yobi https://api.example.com/users
    yobi POST https://api.example.com/users name=John age=30
    yobi GET :8080/api/items Authorization:"Bearer $TOKEN"
    yobi -A basic -a user:pass https://api.example.com/secure-data
    yobi --raw --print B POST https://httpbin.org/anything | jq '.headers["User-Agent"]'

   Options:
  )

  opts.on("-p", "--print FORMAT", "Specify the output format (e.g., 'H' for headers, 'B' for body)") do |format|
    @options[:print] = format || "HB" # default to printing both headers and body
    warn "[Argument Error] Unsupported format: #{format}" unless format.match?(/\A[HBhb]+\z/)
  end

  opts.on("-a", "--auth USER:PASS", "Specify basic authentication credentials") do |auth|
    @options[:auth] = auth
  end

  opts.on("-A", "--auth-type TYPE", "Specify authentication type (e.g., basic, digest, bearer)") do |auth_type|
    @options[:auth_type] = auth_type
  end

  opts.on("--raw", "Print raw request and response data") do
    @options[:raw] = true
  end

  opts.on("-h", "--help", "Print this help message") do
    puts opts
    exit
  end

  opts.on("--offline", "Run in offline mode (prepare request but do not send)") do
    @options[:offline] = true
  end

  opts.on("--follow", "Automatically follow HTTP redirects") do
    @options[:follow] = true
  end

  opts.on("-o", "--output FILE", "Write output to a file instead of STDOUT") do |file|
    @options[:output] = file
  end

  opts.on("--timeout SECONDS", "Set a custom timeout for the request (integer or float)") do |timeout|
    @options[:timeout] = timeout.to_f
  end

  opts.on("--download", "Download response body to a file specified by --output") do
    @options[:download] = true
  end

  opts.on("-v", "--verbose", "Print detailed request and response information") do
    @options[:verbose] = true
  end

  opts.on("--debug", "Print debug information") do
    @options[:debug] = true
    @options[:verbose] = true
  end

  opts.on("--version", "Print app version") do
    puts "#{Yobi.name} v#{Yobi::VERSION}"
    exit
  end
end

parser.parse!(ARGV)

# resolve the HTTP method
method = Yobi.args.http_method?(ARGV[0]) ? ARGV.shift : "GET"

# resolve the URL
url = Yobi.args.url(ARGV.shift)

data = Yobi.args.parse_data(ARGV)
headers = Yobi.args.parse_headers(ARGV)

# prepare authentication header if auth is provided
Yobi.args.auth_header(headers, @options) if @options[:auth]

Yobi::Http.request(method, url, data: data, headers: headers, options: @options) do |http, request|
  options = @options

  # follow redirects, offline, download or standard request mode
  response =
    if options[:follow]
      Yobi::Http.follow_redirects(http.request(request), url, method, data, headers, options)
    elsif options[:offline]
      Yobi::Http.offline_mode(request, options)
    elsif options[:download]
      Yobi::Http.download(request, http, options)
    else
      http.request(request)
    end

  # render output
  if options[:raw]
    Yobi::Renders::Raw.render(request, response, options)
  else
    Yobi::Renders::Colored.render(request, response, options)
  end
end
