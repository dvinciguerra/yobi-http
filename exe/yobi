#!env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift(File.expand_path("../lib", __dir__))

require "erb"
require "json"
require "net/http"
require "optparse"
require "time"
require "tty-markdown"
require "uri"

require "yobi"

# parsing arguments
@options = { print: "HB", auth: nil, auth_type: "basic", verbose: false, raw: false, offline: false }

parser = OptionParser.new do |opts|
  opts.banner = %(
  #{Yobi.name} - #{Yobi.description}

  Usage:
    yobi [METHOD] <url> [HEADER:VALUE] [key=value]

  Examples:
    yobi https://api.example.com/users
    yobi POST https://api.example.com/users name=John age=30
    yobi GET :8080/api/items Authorization:"Bearer $TOKEN"
    yobi -A basic -a user:pass https://api.example.com/secure-data
    yobi --raw --print B POST https://httpbin.org/anything | jq '.headers["User-Agent"]'

   Options:
  )

  opts.on("-p", "--print FORMAT", "Specify the output format (e.g., 'H' for headers, 'B' for body)") do |format|
    @options[:print] = format.upcase || "HB" # default to printing both headers and body
    warn "[Argument Error] Unsupported format: #{format}" unless format.match?(/\A[HB]+\z/i)
  end

  opts.on("-a", "--auth USER:PASS", "Specify basic authentication credentials") do |auth|
    @options[:auth] = auth
  end

  opts.on("-A", "--auth-type TYPE", "Specify authentication type (e.g., basic, digest, bearer)") do |auth_type|
    @options[:auth_type] = auth_type
  end

  opts.on("--raw", "Print raw request and response data") do
    @options[:raw] = true
  end

  opts.on("-h", "--help", "Print this help message") do
    puts opts
    exit
  end

  opts.on("--offline", "Run in offline mode (prepare request but do not send)") do
    @options[:offline] = true
  end

  opts.on("-o", "--output FILE", "Write output to a file instead of STDOUT") do |file|
    @options[:output] = file
  end

  opts.on("-v", "--verbose", "Print detailed request and response information") do
    @options[:verbose] = true
  end

  opts.on("--version", "Print app version") do
    puts "#{Yobi.name} v#{Yobi::VERSION}"
    exit
  end
end

parser.parse!(ARGV)

# resolve the HTTP method
method = Yobi.args.http_method?(ARGV[0]) ? ARGV.shift : "GET"

# resolve the URL
url = Yobi.args.url(ARGV.shift)

data = Yobi.args.parse_data(ARGV)
headers = Yobi.args.parse_headers(ARGV)

# prepare authentication header if auth is provided
Yobi.args.auth_header(headers, @options) if @options[:auth]

pp [method, url, data, headers, @options, ARGV] if ENV["YOBI_DEBUG"]

# Extend Net::HTTPResponse to add util behaviors
def offline_mode(request, options)
  Net::HTTP.class_eval do
    def connect; end
  end

  options[:verbose] = true

  response = Net::HTTPResponse.new("1.1", "200", "OK")
  response["Content-Type"] = "application/json"
  response["Access-Control-Allow-Credentials"] = true
  response["Access-Control-Allow-Origin"] = "*"
  response["Connection"] = "close"
  response["Date"] = Time.now.httpdate
  response["Server"] = "yobi-offline/#{Yobi::VERSION}"
  response["X-Powered-By"] = "Yobi/#{Yobi::VERSION}"
  response.body = body = JSON.pretty_generate({ message: "Offline mode enabled" })

  view = Yobi.view(:output)
  puts TTY::Markdown.parse(view.result(binding), color: :always)

  exit 0
end

def raw_mode(_request, response, options)
  if options[:print].include?("H")
    puts "HTTP/#{response.http_version} #{response.code} #{response.message}"
    response.each_header { |key, value| puts "#{key}: #{value}" }
    puts
  end

  body = response.parsed_body
  puts body if options[:print].include?("B") && body

  exit 0
end

Yobi.request(method, url, data: data, headers: headers, options: @options) do |http, request|
  options = @options

  offline_mode(request, options) if options[:offline]

  response = http.request(request)

  raw_mode(request, response, options) if options[:raw]

  body = JSON.pretty_generate(response.parsed_body)

  view = Yobi.view(:output)
  output_result = view.result(binding)

  if options[:output]
    file = File.expand_path(options[:output], Dir.pwd)
    File.write(file, output_result, mode: "w")
  else
    puts TTY::Markdown.parse(output_result, color: :always)
  end
end
